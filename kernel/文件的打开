======================
如何打开文件（设备）

在文件kio.c 中将要实现内核中重要的功能将所有的系统设备驱动和文件系统接口联系起来，下面给出打开文件（设备）的方法.

打开文件（设备）的接口函数原型为 
	int open(struct kfile *pkf,struct kinode *pki) ====>  Function A
在kio.c中的接口为
	struct kfile *kopen(_core_ const char * filename,int mode) ====> Function B
这两个原型面向的对象分别是核心驱动和用户，因此需要在这中间做一个转换，他们的关系图如下

        +------------------------------------+
        +            应用程序层                +
        +------||----------------------||----+
               ||                      ||
        +------||----------------------||----+
        +            文件抽象层                +
        +------||----------------------||----+
               ||        ||            ||
  '''''''''''''||''''''''||''''''''''''||'''''''''''
  |     +------||----+   ||       +----||----+     |
  |     +文件系统驱动 +   ||       +设备驱动层 +     |
  |     +------||----+   ||       +----||----+     |
  |            ||        ||            ||          |
  |     +------||--------||--+         ||          |
  |     +   块设备驱动层      +         ||         |
  |     +------||------------+         ||          |
  |            ||                      ||   驱动层 |
  '''''''''''''||''''''''''''''''''''''||'''''''''''
        +------||----------------------||----+
        +               硬件层                +
        +------------------------------------+

现在要做的工作就是将应用程序层，和驱动层联系在一起，也就是要做的完善文件抽象层。
在应用程序进行系统调用open时将进行一系列判断
<1> 当前任务是否打开过这个文件？
	如果打开过则判断打开方式是否和前一次打开的方式是否相同，相同则返回已经打开的文件
    指针，若没有则继续判断.
<2> 内核中是否打开过这个文件？
    如果已经打开则通知文件系统驱动或直接通知设备驱动，根据驱动返回状态确定返回结果,
    如果没有打开则继续判断.
<3> 是否是内核中的设备节点？
    如果是则通知设备驱动，并根据设备驱动返回状态确定返回结果.
<4> 通知文件系统驱动，检查是否存在该文件，根据文件系统驱动返回状态确定返回结果.

这里还要说的是关于系统中的挂载点树，在系统初始化时将某个设备当成时根设备挂载到/，后面的
所有文件操作都将基于根设备进行，其他的块设备也需要挂载到根设备的某个目录进行访问(这里是
从unix中借鉴的,感谢伟大的UNIX，LINUX)。
