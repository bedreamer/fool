==============
上下文切换/
    + 说明
    + 切换什么
         + 堆栈切换
         + 任务切换
         + CPU状态字的切换
    + 发生了什么
         + 有特权级变化
         + 没有特权级变化
    + 切换规则
         + 通用规则
         + 现场保护
         + 现场恢复
    + 要做什么

==============
说明
	上下文切换是一个很复杂的过程，牵扯很多的内容要去关注。因为我无法一次性的写出这一部分的代码，
因此在这里用文档的形式将切换的过程进行一个梳理，使得思路变得清晰。

==============
切换什么
	上下文切换包含很多东西要切换，总的有堆栈的切换，任务的切换，CPU状态字的切换。
	堆栈切换是比较复杂的，因为系统中包含4中堆栈，分别是系统栈（systemstack,在系统初始化，系统
中断首先使用），异常中断栈（intstack,发生异常，中断时使用），线程内核栈（taskcorestack,当线
程从用户态切到核心态接受系统服务时使用），线程私有栈（taskstack,线程在用户模式下使用的栈）。
	任务切换相对于堆栈切换向上走了一个层次，任务是一个抽象过的结构，只需用将任务所需的信息压入
堆栈并冲堆栈iret就可以完成任务的切换。是相对简单的一个。
	CPU状态字的切换在中断(软硬中断，异常)发生时CPU将标志寄存器，中断位置的EIP，代码段选择自
CS，被中断的任务的用户态esp(有特权级变化)，被中断的任务的用户态栈选择子（有特权级变化）,通用寄
存器，在中断后首先要做的就是保存CPU现场将通用寄存器进行压栈保存。

==============
发生了什么
	当CPU收到中断时系统栈会有如下情形发生
 @有特权级变化
 	前一状态在任务私有栈中
  H______________ @ systemstack.
   +  user.esp   +
   +  user.ss    +
   + user.eflags +
   +  user.cs    +
   +  user.eip   +
   .             .
  L.             .
       图(1)

  @没有特权级变化，也就是中断重入,由于在切入对应栈的时候可屏蔽中断被屏蔽，因此现在要多种情况.
	前一状态在中断处理过程中.   
  H______________ @ intstack
   +?????????????+
   +?????????????+
   +?????????????+
   + core.eflags +
   +  core.cs    +
   +  core.eip   +
   .             .
       图(2)

	前一状态在系统调用过程中
  H______________ @ taskcorestack
   +?????????????+
   +?????????????+
   +?????????????+
   + core.eflags +
   +  core.cs    +
   +  core.eip   +
  L.             .
       图(3)

在没有特权级变化的中断过程中，由于CPU不去切换堆栈因此CPU当前状态字被压入了当前所在的堆栈中。
但为了严格恪守切换规则，现在必须确定中断的类型，并将堆栈中的CPU状态字拷贝到对应的栈中之后再
继续向下执行对应的指令。

==============
切换规则
	规则1.ring3->ring0 堆栈应通过tss切换到systemstack.
	规则2.处理过程必须使用对应的过程堆栈.也就是中断--intstack,系统调用--taskcorestack.
	规则3.没有切换到对应的堆栈时禁止可屏蔽中断.
	现场保护
	@1.当发生中断时第一件事是将当前所有的通用寄存器压入当前堆栈进行保护.
	@2.当第一次切入到内核时直接将CPU的状态保存到对应任务的寄存器结构中.
	@3.当确定中断类型后将保护的通用寄存器拷贝到对应的堆栈中.
	@4.若是不同类型的中断重入则同时保存当前的堆栈信息到将要切换的堆栈中去.
	现场恢复
	@1.仅仅恢复到被中断前的状态.
	@2.恢复时如果没有特权级变化则确定是否是重入中断的返回.
	@3.如果是重入中断的返回,则一并恢复堆栈位置.

==============
要做什么
	下面给出几种情况的伪代码

@ 硬件中断发生.
ring3----                       ------------------------
ring0   |-----hw int------------|
          现在堆栈已经切换到systemstack中如图(1)

start
    cli
    store   所有寄存器到当前堆栈
    mov	    eax,esp
    mov	    esp,intstack
    store   从systemstack中将寄存器信息拷贝到当前堆栈中
    sti
    call    int_procedure
    restor  从当前堆栈中恢复寄存器结构
    iret
end

@ 硬件中断发生,又发生了硬件中断
ring3----                                ----------------
ring0   |---hw int---|            |------|
ring0                |---hw int---|
	中断时堆栈已经在intstack中如图(2)

start
    cli
    store   所有寄存器到当前堆栈
    sti
    call    int_procedure
    restor  从当前堆栈中恢复寄存器结构
    iret
end

@ 系统调用后:
ring3----            ------------------------------------
ring0   |--sys call--|
		现在堆栈已经切换到systemstack中如图(1)

start
    cli
    store   所有寄存器到当前寄存器
    mov	    eax,esp
    mov	    esp,taskcorestack
    store   从systemstack中将寄存器信息拷贝到当前堆栈中
    sti
    call    sys_call_procedure
    restor  从当前堆栈中恢复寄存器结构
    iret
end

@ 系统调用后发生硬件中断
ring3----                             -------------------
ring0   |--sys call--|          |-----|
ring0                |--hw int--|
		现在堆栈已经在taskcorestack中如图(3)

start
    cli
    store   所有寄存器到当前堆栈中
    mov	    eax,esp
    mov	    esp,intstack
    push    eax
    sti
    call    irqprocedure
    pop	    eax
    mov	    esp,eax
    restor  从当前堆栈中恢复寄存器结构
    iret
end








